---
title: "Undergraduate Research"
author: "Donald Dinerman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Using Data to Support Students

## Project Description

The Statistics & Data Science Advising team wants to use data to better support students. Using anonymized course performance data, your team will assess and seek to answer numerous questions. The dataset will include course final grades for courses Statistics & Data Science graduates have taken over the past several (approximately 6) years. Data will include a student identifier, courses taken, final grades in courses, the class level of the student when they took the course, student major when they took the course, and the semester the courses were taken. 

## Read Data

```{r, include=F}
#Load libraries

library(dplyr)
library(tidyr)
library(zoo)
library(kableExtra)
library(stringr)
library(ggplot2)
```

```{r}
stat_df = read.csv("stats_data.csv")
```

Questions:

1. For first enrolled, I assume F and S are Fall and Spring. But what is M? M is 1st summer term

2. For major, what is H00? H00 means undeclared

3. What does class_id signify? (e.g., 1 = freshman, ..., 4 = senior)

4. What is M and N for semester? first and second term in summer

5. There are instances where first enroll happens after the course semester. Does this mean the student enrolled after they took the course, what's up with that? can designate first semester of courses as first enroll variable

6. How to designate pre-reqs? label as go, from forward to back(e.g., took 401 lets see when and how you did in 226)

7. How to identify electives and core classes? course catalogs

## Prep Data

```{r}
#Inconsistencies between first enrolled and course semester

char_remover = function(x){gsub("[^0-9.-]", "", x) %>% as.numeric()}

sem = char_remover(stat_df$semester) - char_remover(stat_df$first_enrolled)

#instances where first enroll date > semester date (weird, need explanation) (119 students) 
```

```{r}
#identify students with discrepancy
discrep_student = stat_df[which(sem < 0),] %>%
  pull(1)

`%!in%` = Negate(`%in%`) #create %!in% operator

#If first enrolled > semester, then make first_enrolled = the first semester - (class_id - 1)
#this is an approximation since we can't gather semester based information on first_enrolled (whether they enrolled in F,S,M,N)
discrep_fixer = function(semester_vec, class_id_vec){
  
  letter_part = substr(semester_vec, 1, 1) #get letter
  
  number_part = substr(semester_vec, 2, 3) %>% as.numeric() #get numbers

  add_class_id = number_part - (class_id_vec - 1) #arithmetic function
  
  paste(letter_part, add_class_id, sep = "") #concatenate
}
```


```{r}
#Fix the discrepancy above

#make semester factor then arrange by semester to take order of first

reference_level = c("F12", #add these two semesters based on discrep_fixer approximation for first_semester
                    "F13", 
                    "F14", "S15", "M15", "N15",
                    "F15", "S16", "M16", "N16",
                    "F16", "S17", "M17", "N17",
                    "F17", "S18", "M18", "N18",
                    "F18", "S19", "M19", "N19",
                    "F19", "S20")

stat_df$semester = factor(stat_df$semester, levels = reference_level)

stat_df$first_enrolled = factor(stat_df$first_enrolled, levels = reference_level)

first_sem_discrep = stat_df %>% #first semester for discrepancy students
  group_by(student) %>% 
  arrange(semester) %>% #need to arrange by semester to capture true first semester entry
  summarize_all(first) %>% 
  select(student, semester, class_id) %>%
  filter(student %in% discrep_student)

first_sem_discrep$discrep_var = discrep_fixer(first_sem_discrep$semester, first_sem_discrep$class_id)

first_sem_discrep_fin = first_sem_discrep %>% select(-c("semester", "class_id"))

first_enroll_non_discrep = stat_df %>% #ppl w/o discrepancy may have first semester earlier than their first class in the df
  filter(student %!in% discrep_student) %>% 
  select(student, first_enrolled) %>%
  unique() %>%
  rename(discrep_var = first_enrolled)

first_sem = rbind(first_sem_discrep_fin, first_enroll_non_discrep) %>%
  arrange(student)

first_sem$discrep_var = factor(first_sem$discrep_var, levels = reference_level)

discrep_fixed_df = stat_df[,-4] %>% #remove old first_enrolled
  left_join(., first_sem, "student") %>%
  rename(first_enrolled = discrep_var) %>% #rename variables
  select(student, class_id, major, first_enrolled, everything()) #set order we view variables

#head(discrep_fixed_df,3)
```

*this needs work*
```{r}
#Calculate graduation year
#Can instead: find first semester entry, to the substr thing w semester but conditional on class_id
#may have to calculate grad year depending on whether first_enrolled is fall (spring grad, next year) or spring (winter grad same year)


#can't calculate grad year like this bc some student's last semester in data is there sophomore and junior year
#also would need to at least arrange by semester

#grad_year = discrep_fixed_df %>% 
#  group_by(student) %>% 
#  arrange(first_enrolled) %>%
#  summarize_all(last) %>% 
#  mutate(prelim_year = 2000 + as.numeric(substr(first_enrolled,2,3)),
#         graduation_year = prelim_year + class_id) %>% 
# select(student, graduation_year)

#df = stat_df %>% 
#  left_join(., grad_year, "student") %>% 
#  select(-first_enrolled) %>% 
#  rename(semester = semester.x, first_enrolled = semester.y) %>% 
#  select(student, class_id, major, first_enrolled, graduation_year, everything())
```

```{r}
#Some students switched majors midway
#using merge, assign students who switched majors midway to the major they have in their last semester
#eg., STA to ECOSTA is now a ECOSTA for all the semesters

#major in student's last semester
declared_students = discrep_fixed_df %>%
  group_by(student) %>%
  arrange(semester) %>%
  summarise(major) %>%
  summarise_all(last) %>% #takes last semester student is recorded
  filter(major != "H00") #filter out non-majors (H00: undeclared) if the last semester is H00

#Join dfs
drop.cols = c("major.y")

#make sure left df is most up to date one

merged_df = left_join(discrep_fixed_df, declared_students, "student") %>% #keeps all x rows, matches y rows by student
  mutate(major = major.y, .before = first_enrolled) %>% #major.y are the fin semester majors
  select(-drop.cols) #removes duplicate major.y from previous df

remove_non_majors = na.omit(merged_df) %>% #NA's are H00 majors so we remove them
  arrange(student, semester) 
```

```{r}
#Major change information (primarily for EDA insight and not modelling)

major_changes_df = remove_non_majors %>% 
   group_by(student) %>% 
   mutate(major_after = lead(major.x)) %>% #Alan explain lead() function and purpose of filtering
   filter(major.x != major_after) %>% 
   ungroup()

major_changes = major_changes_df %>% 
  select(major.x, major_after)

major_changes_counts = major_changes %>%
  count(., major.x, major_after) %>% 
   filter(major.x != "H00" & major_after != "H00") %>% 
   arrange(desc(n))
 
before = with(major_changes_counts, rep(x = major.x, times = n))

after = with(major_changes_counts, rep(x = major_after, times = n))

major_change_eda_df = data.frame(before, after)
```

```{r}
#remove grad classes
#(1) keep 10-xxx, (2) remove xx-600 >
#######Issue: Master courses and other omitted courses still feed into semester units_carried

#identify xx-600 >
index_1 = grepl("^..[6-9]", remove_non_majors$course)

df_1 = remove_non_majors[index_1,]

#identify 10-xxx
index_2 = grepl("^[1][0]...", df_1$course)

df_2 = df_1[!index_2,] #get courses that are don't start with 10 but end with 600 or greater

undergrad_df = remove_non_majors[remove_non_majors$course %!in% df_2$course,]
```

```{r}
#Calculate GPA
#By semester (updating each semester based on previous semester and total QPA)
#Quality Points = units * grade
#QPA = sum(QP)/sum(units)
#(A = 4, B = 3, C = 2, D = 1, R = 0, P/N/O/W doesn't count towards GPA)

#case_when is type-strict meaning you need to return values of same type
#classify P/N/O/W as 100 and then remove rows where number_grade == 100
undergrad_df$number_grade = case_when(
  undergrad_df$grade == "A" ~ 4,
  undergrad_df$grade == "B" ~ 3,
  undergrad_df$grade == "C" ~ 2,
  undergrad_df$grade == "D" ~ 1,
  undergrad_df$grade == "R" ~ 0,
  TRUE ~ 100
  )

basic_grade_df = undergrad_df[undergrad_df$number_grade != 100,] #don't calculate QPA for P/N/O/W grades

basic_grade_df$quality_points = basic_grade_df$units*basic_grade_df$number_grade

#QPA by semester

non_updating_QPA = basic_grade_df %>% 
  group_by(student, semester) %>%
  summarise(n_courses = n(),
            QP_sum = sum(quality_points), 
            unit_sum = sum(units), 
            QPA = round(QP_sum/unit_sum,2)
            )

#create an updating QPA that is weighed by previous semesters (using cumulative sums)
updating_QPA = non_updating_QPA %>%
  group_by(student) %>%
  summarise(semester, 
            cumulative_QP = cumsum(QP_sum),
            cumulative_unit = cumsum(unit_sum),
            updating_QPA = round(cumulative_QP/cumulative_unit, 2)) %>%
  select(student, semester, updating_QPA)

#create all combinations with students and semesters
QPA_students = pull(updating_QPA, 1)
leveled_semester = factor(reference_level, levels = reference_level)

student_semester_combo_df = crossing(student = QPA_students, semester = leveled_semester)

#left join with updating_QPA
intermediate_combo_QPA = left_join(student_semester_combo_df, updating_QPA, by = c("student", "semester"))

#Fill NA with previous QPA from student's semester grouped by student
combo_QPA = intermediate_combo_QPA %>%
  group_by(student) %>% #information being lost with na.locf (e.g., s0001 is 20 entries instead of 22) --> change na.rm = T to F
  summarise(semester, QPA = na.locf(updating_QPA, na.rm = F)) #its dropping the NAs after last entry for student i related with student

#left_join filled combo df with the main one by student and semester

joined_updated_QPA_df = left_join(undergrad_df, combo_QPA, by = c("student", "semester"))

# joined_updated_QPA_df[is.na(joined_updated_QPA_df),] %>% nrow() = 10

# Check the QPA NA
clean_joined_updated_QPA_df = na.omit(joined_updated_QPA_df) #removes 10 rows with NAs

clean_joined_updated_QPA_df$semester = factor(clean_joined_updated_QPA_df$semester, levels = reference_level) #set factor and level

#head(clean_joined_updated_QPA_df,3)
```

```{r}
#export cleaned data
wrangled_data = write.csv(clean_joined_updated_QPA_df)
```

## EDA

### Tables

General Note: Need to adjust df on EDA to reflect the most up to date wrangled data

```{r}
#make proportion table for courses
#e.g., 0.001 kids take 21-366

n_students = clean_joined_updated_QPA_df$student %>% unique() %>% length()

prop_tab = (table(clean_joined_updated_QPA_df$course) / n_students) %>% round(4) #round by 4 so that percentage is rounded by 2

percentage_course_df = as.data.frame(prop_tab * 100) %>% arrange(-Freq)

colnames(percentage_course_df) = c("Course", "% of Students")

head(percentage_course_df, 5)  %>% 
  kbl(caption = "Table 1: Top 5 Courses Taken", booktabs = T) %>% 
  kable_paper("hover", full_width = T)
```

```{r}
#group prop courses by major
hold = declared_students %>% #to get students per major
  group_by(major) %>%
  summarise(count = n())

test = clean_joined_updated_QPA_df %>% #to get students in course by major
  group_by(major) %>%
  count(course, name = "n_course")

percentage_course_by_major = left_join(test, hold, "major") %>%
  mutate(prop = round((n_course/count)*100, 2)) %>%
  group_by(major) %>%
  slice_max(n = 3, order_by = prop, with_ties = F) %>%
  arrange(major, -prop)

colnames(percentage_course_by_major) = c("Major", "Course", "Students Taken", "Students in Major", "% of Students")

percentage_course_by_major[,c(2,3,5)] %>%
  kbl(caption = "Table 2: Top 3 courses taken across majors", booktabs = T) %>% 
  kable_paper("hover", full_width = T) %>%
    pack_rows(index = c("ECOSTA" = 3, "STA" = 3, "STAMACH" = 3))
```

```{r}
#proportion retake classes
#top 10 courses that are retaken

course_counts = clean_joined_updated_QPA_df %>%
  group_by(student, course) %>%
  summarise(times_taken = n()) %>%
  filter(times_taken > 1)

#doesn't take into account if 1 student retook a class more than once
retake_course_counts = course_counts %>%
  group_by(course) %>%
  summarise(n_students_retake = n()) %>%
  mutate(retake_percentage = round(n_students_retake/n_students,4)*100) %>%
  arrange(-n_students_retake)

colnames(retake_course_counts) = c("Course", "Students Retaken", "Retake %") 

head(retake_course_counts, 5) %>%  
  kbl(caption = "Table 3: Top 5 courses retaken", booktabs = T) %>% 
  kable_paper("hover", full_width = T)
```

### Graphs

```{r}
#Grade distribution function by course

class_grade = table(clean_joined_updated_QPA_df$course, clean_joined_updated_QPA_df$grade) %>% 
  as.data.frame() %>%
  pivot_wider(names_from = Var2, values_from = Freq) %>%
  mutate(n_students = rowSums(.[2:10])) %>%
  rename(Course = Var1)

prop_class_grade = class_grade %>%
  mutate(across(c(2:10), .fns = ~./(n_students/100)) %>% #n_students/100 puts value in percentage terms
           round(2)) %>%
  #filter(n_students >= 20) %>%
  arrange(-n_students)

course_grade_func = function(class){

  class = as.character(class) #accept numeric and character classes
  
  drop = c("Course", "n_students")

  course_df = prop_class_grade %>% 
    filter(Course == class) %>% 
    select(-drop) %>%
    pivot_longer(everything())
             
  ggplot(course_df, aes(x = name, y = value)) +
    geom_col(col = "black", fill = "steelblue") +
    geom_text(aes(label = value), position = position_dodge (width = 0.9), vjust = -0.25) + #adds text labels
    labs(title = paste("Grade Distribution for",class), x = "Grades", y = "Grade Distribution (%)")

}

#for loop graph output
top_n_classes = prop_class_grade[,1] %>% pull(1)

for(i in 1:5) {
  course_grade_func(top_n_classes[i]) %>% print()
}

course_grade_func(36402) #basic use
```

```{r}
#how kids do their first time vs their second time taking a class

simple_filter_retake = clean_joined_updated_QPA_df %>%
  group_by(student, semester) %>%
  summarise(course, grade) %>%
  filter(student %in% course_counts$student, #Filtering by student and course combo from retake df
         course %in% course_counts$course) #filtering on students and classes, since classes aren't unique gonna get non retakes

complete_retake = left_join(simple_filter_retake, course_counts, by = c("student", "course")) %>% 
  filter(times_taken > 1) #to get rid of non-retake courses

#some kids took this class more than 2 times, just take the first and last time they took a class to compare performance
first_take = complete_retake %>%
  group_by(student, course) %>%
  slice_max(n = 1, order_by = semester)

last_take = complete_retake %>%
  group_by(student, course) %>%
  slice_min(n = 1, order_by = semester)

first_and_last_takes = rbind(first_take, last_take) %>% 
  arrange(student, course, semester)

head(first_and_last_takes)

#how do we want to quantify P/N/O/W grades?
#36-300 internship course (can remove), filter out capstone?
#list of internship/capstone courses,
#take first/last grade counts grouped by course, then take proportion of counts

```

```{r}
#popular electives by major
```

```{r}
#contingency tables on performance with class x and class y
```

```{r}
#y1 and y2 are classes
#x is grades
#faceted by whether they took this pre-req class
```

```{r}
#Based class EDA on some group (e.g., second year stats courses, 36-3## courses, econ electives, etc.)

```

