---
title: "Undergraduate Research"
author: "Donald Dinerman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Using Data to Support Students

## Project Description

The Statistics & Data Science Advising team wants to use data to better support students. Using anonymized course performance data, your team will assess and seek to answer numerous questions. The dataset will include course final grades for courses Statistics & Data Science graduates have taken over the past several (approximately 6) years. Data will include a student identifier, courses taken, final grades in courses, the class level of the student when they took the course, student major when they took the course, and the semester the courses were taken. 

## Read Data

```{r, include=F}
#Load libraries

library(dplyr)
library(tidyr)
library(zoo)
library(kableExtra)
library(stringr)
```

```{r}
stat_df = read.csv("stats_data.csv")
```

Questions:

1. For first enrolled, I assume F and S are Fall and Spring. But what is M? M is 1st summer term

2. For major, what is H00? H00 means undeclared

3. What does class_id signify? (e.g., 1 = freshman, ..., 4 = senior)

4. What is M and N for semester? first and second term in summer

5. There are instances where first enroll happens after the course semester. Does this mean the student enrolled after they took the course, what's up with that? can designate first semester of courses as first enroll variable

6. How to designate pre-reqs? label as go, from forward to back(e.g., took 401 lets see when and how you did in 226)

7. How to identify electives and core classes? course catalogs

## Prep Data

```{r}
#Inconsistencies between first enrolled and course semester

char_remover = function(x){gsub("[^0-9.-]", "", x) %>% as.numeric()}

sem = char_remover(stat_df$semester) - char_remover(stat_df$first_enrolled)

#instances where first enroll date > semester date (weird, need explanation) (119 students) 
#stat_df[which(sem < 0),]
```

```{r}
#Fix the discrepancy above
#If first enrolled > semester, then make first_enrolled = the first semester shown in data for a student (conditional)

discrep_student = stat_df[which(sem < 0),] %>%
  pull(1)

`%!in%` = Negate(`%in%`) #create %!in% operator

#make semester factor then arrange by semester to take order of first

reference_level = c("F14", "S15", "M15", "N15",
                    "F15", "S16", "M16", "N16",
                    "F16", "S17", "M17", "N17",
                    "F17", "S18", "M18", "N18",
                    "F18", "S19", "M19", "N19",
                    "F19", "S20")

stat_df$semester = factor(stat_df$semester, levels = reference_level)

first_sem_discrep = stat_df %>% #first semester for discrepancy students
  group_by(student) %>% 
  arrange(semester) %>% #need to arrange by semester to capture true first semester entry
  summarize_all(first) %>% 
  select(student, semester) %>%
  filter(student %in% discrep_student)

first_enroll_non_discrep = stat_df %>% #ppl w/o discrepancy may have first semester earlier than their first class in the df
  filter(student %!in% discrep_student) %>% 
  select(student, first_enrolled) %>%
  unique() %>%
  rename(semester = first_enrolled)

first_sem = rbind(first_sem_discrep, first_enroll_non_discrep) %>%
  arrange(student)

discrep_fixed_df = stat_df[,-4] %>% #remove old first_enrolled
  left_join(., first_sem, "student") %>%
  rename(semester = semester.x, first_enrolled = semester.y) %>% #rename variables
  select(student, class_id, major, first_enrolled, everything()) #set order we view variables

discrep_fixed_df
```

*this needs work*
```{r}
#Calculate graduation year
#Can instead: find first semester entry, to the substr thing w semester but conditional on class_id
#may have to calculate grad year depending on whether first_enrolled is fall (spring grad, next year) or spring (winter grad same year)


#can't calculate grad year like this bc some student's last semester in data is there sophomore and junior year
#also would need to at least arrange by semester
grad_year = discrep_fixed_df %>% 
  group_by(student) %>% 
  arrange(first_enrolled) %>%
  summarize_all(last) %>% 
  mutate(prelim_year = 2000 + as.numeric(substr(first_enrolled,2,3)),
         graduation_year = prelim_year + class_id) %>% 
  select(student, graduation_year)

#df = stat_df %>% 
#  left_join(., grad_year, "student") %>% 
#  select(-first_enrolled) %>% 
#  rename(semester = semester.x, first_enrolled = semester.y) %>% 
#  select(student, class_id, major, first_enrolled, graduation_year, everything())
```

```{r}
#filter out non-majors (H00: undeclared) if the last semester is H00
#e.g., if STA last semester, change H00 to STA

h00_students = discrep_fixed_df %>%
  group_by(student) %>%
  arrange(semester) %>% #have to arrange by semester to get true order
  summarise(major) %>%
  summarise_all(last) %>% #takes last semester student is recorded
  filter(major == "H00") %>%
  pull(1)

declared_stat_df = stat_df %>%
  filter(student %!in% h00_students)
```

```{r}
#Some students switched majors midway
#using merge, assign students who switched majors midway to the major they have in their last semester
#eg., STA to ECOSTA is now a ECOSTA for all the semesters

#major in student's last semester
declared_students = discrep_fixed_df %>%
  group_by(student) %>%
  arrange(semester) %>%
  summarise(major) %>%
  summarise_all(last) %>% #takes last semester student is recorded
  filter(major != "H00")

#Join dfs
drop.cols = c("major.x", "major.y")

merged_df = left_join(declared_stat_df, declared_students, "student") %>% #keeps all x rows, matches y rows by student
  mutate(major = major.y, .before = first_enrolled) %>% #major.y are the fin semester majors
  select(-drop.cols) #removes duplicate major.y and major.x from previous df
```

```{r}
#remove grad classes
#(1) keep 10-xxx, (2) remove xx-600 >
#######Issue: Master courses and other omitted courses still feed into semester units_carried

#identify xx-600 >
index_1 = grepl("^..[6-9]", merged_df$course)

df_1 = merged_df[index_1,]

#identify 10-xxx
index_2 = grepl("^[1][0]...", df_1$course)

df_2 = df_1[!index_2,] #get courses that are don't start with 10 but end with 600 or greater

undergrad_df = merged_df[merged_df$course %!in% df_2$course,]
```

```{r}
#Calculate GPA
#By semester (updating each semester based on previous semester and total QPA)
#Quality Points = units * grade
#QPA = sum(QP)/sum(units)
#(A = 4, B = 3, C = 2, D = 1, R = 0, P/N/O/W doesn't count towards GPA)

#case_when is type-strict meaning you need to return values of same type
#classify P/N/O/W as 100 and then remove rows where number_grade == 100
undergrad_df$number_grade = case_when(
  undergrad_df$grade == "A" ~ 4,
  undergrad_df$grade == "B" ~ 3,
  undergrad_df$grade == "C" ~ 2,
  undergrad_df$grade == "D" ~ 1,
  undergrad_df$grade == "R" ~ 0,
  TRUE ~ 100
  )

basic_grade_df = undergrad_df[undergrad_df$number_grade != 100,] #don't calculate QPA for P/N/O/W grades

basic_grade_df$quality_points = basic_grade_df$units*basic_grade_df$number_grade

#QPA by semester

non_updating_QPA = basic_grade_df %>% 
  group_by(student, semester) %>%
  summarise(n_courses = n(),
            QP_sum = sum(quality_points), 
            unit_sum = sum(units), 
            QPA = round(QP_sum/unit_sum,2)
            )

#create an updating QPA that is weighed by previous semesters (using cumulative sums)
updating_QPA = non_updating_QPA %>%
  group_by(student) %>%
  summarise(semester, 
            cumulative_QP = cumsum(QP_sum),
            cumulative_unit = cumsum(unit_sum),
            updating_QPA = round(cumulative_QP/cumulative_unit, 2)) %>%
  select(student, semester, updating_QPA)

#create all combinations with students and semesters
QPA_students = pull(updating_QPA, 1)
leveled_semester = factor(reference_level, levels = reference_level)

student_semester_combo_df = crossing(student = QPA_students, semester = leveled_semester)

#left join with updating_QPA
intermediate_combo_QPA = left_join(student_semester_combo_df, updating_QPA, by = c("student", "semester"))

#Fill NA with previous QPA from student's semester grouped by student
combo_QPA = intermediate_combo_QPA %>%
  group_by(student) %>% #information being lost with na.locf (e.g., s0001 is 20 entries instead of 22) --> change na.rm = T to F
  summarise(semester, QPA = na.locf(updating_QPA, na.rm = F)) #its dropping the NAs after last entry for student i related with student

#left_join filled combo df with the main one by student and semester

joined_updated_QPA_df = left_join(undergrad_df, combo_QPA, by = c("student", "semester"))

#QPA processing created 10 NA records
#joined_updated_QPA_df[is.na(joined_updated_QPA_df),] %>% nrow() equals 10

#Can backtrack to try to find them (difficult) --> anti_join to find
#Or delete these 10 records as they seem obscure (outliers) anyway
clean_joined_updated_QPA_df = na.omit(joined_updated_QPA_df) #removes 10 rows with NAs

clean_joined_updated_QPA_df$semester = factor(clean_joined_updated_QPA_df$semester, levels = reference_level) #set factor and level

head(clean_joined_updated_QPA_df,3)
```

## EDA

### Tables

General Note: Need to adjust df on EDA to reflect the most up to date wrangled data
```{r}
#EDA on classes are going to have to be based on some group (e.g., second year stats courses, 36-3## courses, econ electives, etc.)
table(clean_joined_updated_QPA_df$course, clean_joined_updated_QPA_df$grade) %>% head()

unique(clean_joined_updated_QPA_df$course) %>% length() #number of classes
```

```{r}
#make proportion table for courses
#e.g., 0.001 kids take 21-366

n_students = clean_joined_updated_QPA_df$student %>% unique() %>% length()

prop_tab = (table(clean_joined_updated_QPA_df$course) / n_students) %>% round(4) #round by 4 so that percentage is rounded by 2

percentage_course_df = as.data.frame(prop_tab * 100) %>% arrange(-Freq)

colnames(percentage_course_df) = c("Course", "% of Students")

head(percentage_course_df, 5)  %>% 
  kbl(caption = "Table 1: Top 5 Courses Taken", booktabs = T) %>% 
  kable_paper("hover", full_width = T)
```

```{r}
#group prop courses by major
hold = declared_students %>% #to get students per major
  group_by(major) %>%
  summarise(count = n())

test = clean_joined_updated_QPA_df %>% #to get students in course by major
  group_by(major) %>%
  count(course, name = "n_course")

percentage_course_by_major = left_join(test, hold, "major") %>%
  mutate(prop = round((n_course/count)*100, 2)) %>%
  group_by(major) %>%
  slice_max(n = 3, order_by = prop, with_ties = F) %>%
  arrange(major, -prop)

colnames(percentage_course_by_major) = c("Major", "Course", "n_course", "n_major", "% of Students")

percentage_course_by_major[,c(2,5)] %>%
  kbl(caption = "Table 2: Top 3 courses taken across majors", booktabs = T) %>% 
  kable_paper("hover", full_width = T) %>%
    pack_rows(index = c("ECOSTA" = 3, "STA" = 3, "STAMACH" = 3))
```

```{r}
#proportion retake classes
#top 10 courses that are retaken

course_counts = clean_joined_updated_QPA_df %>%
  group_by(student, course) %>%
  summarise(times_taken = n()) %>%
  filter(times_taken > 1)

#doesn't take into account if 1 student retook a class more than once
retake_course_counts = course_counts %>%
  group_by(course) %>%
  summarise(n_students_retake = n()) %>%
  mutate(retake_percentage = round(n_students_retake/n_students,4)*100) %>%
  arrange(-n_students_retake)

colnames(retake_course_counts) = c("Course", "Students Retaken", "Retake %") 

head(retake_course_counts[,c(1,3)], 5) %>%  
  kbl(caption = "Table 3: Top 5 courses retaken", booktabs = T) %>% 
  kable_paper("hover", full_width = T)
```

### Graphs

```{r}
#how kids do their first time vs their second time taking a class

simple_filter_retake = clean_joined_updated_QPA_df %>%
  group_by(student, semester) %>%
  summarise(course, grade) %>%
  filter(student %in% course_counts$student, #Filtering by student and course combo from retake df
         course %in% course_counts$course) #filtering on students and classes, since classes aren't unique gonna get non retakes

complete_retake = left_join(simple_filter_retake, course_counts, by = c("student", "course")) %>% 
  filter(times_taken > 1) #to get rid of non-retake courses

#some kids took this class more than 2 times, just take the first and last time they took a class to compare performance
first_take = complete_retake %>%
  group_by(student, course) %>%
  slice_max(n = 1, order_by = semester)

last_take = complete_retake %>%
  group_by(student, course) %>%
  slice_min(n = 1, order_by = semester)

first_and_last_takes = rbind(first_take, last_take) %>% 
  arrange(student, course, semester)

first_and_last_takes

#how do we want to quantify P/N/O/W grades?
#36-300 internship course (can remove), filter out capstone?
#list of internship/capstone courses,
#take first/last grade counts grouped by course, then take proportion of counts

```

```{r}
#popular electives by major
```

```{r}
#contingency tables on performance with class x and class y
```

```{r}
#y1 and y2 are classes
#x is grades
#faceted by whether they took this pre-req class
```


